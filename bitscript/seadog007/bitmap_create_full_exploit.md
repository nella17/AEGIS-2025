# CRITICAL: Bitmap Create Signed Integer Overflow - FULL EXPLOIT CHAIN

## The Vulnerability Chain

### Step 1: Bypass Bounds Check (bitmap_create, line 6)

**Input:**
```bitscript
bitmap b1 = create(9223372036854775807, 2);
```

**What happens:**
- `a1 = 9223372036854775807` (INT64_MAX = 0x7FFFFFFFFFFFFFFF)
- `a2 = 2`
- Check: `a2 * a1 > 0x800000`
- `2 * INT64_MAX = 0xFFFFFFFFFFFFFFFE` â†’ **overflows to -2** (signed)
- `-2 > 0x800000` = **FALSE** â†’ **Check PASSES!** âœ…

### Step 2: Allocate Tiny Buffer (bitmap_create, line 19-22)

**After check passes:**
- Line 19: `v2 = a2 * a1 + 7 = -2 + 7 = 5`
- Line 20: `if (v2 < 0)` â†’ FALSE (5 is not negative)
- Line 22: `malloc((int)(v2 >> 3))` = `malloc((int)(5 >> 3))` = `malloc(0)`
- **Result:** Tiny buffer allocated (minimum chunk size, typically 0x20-0x30 bytes)
- But `width = INT64_MAX`, `height = 2` stored in bitmap struct

### Step 3: Out-of-Bounds Write (bitmap_set, line 14-19)

**When calling:**
```bitscript
set(b1, 0, 1, 1);  # x=0, y=1, value=1
```

**bitmap_set calculation:**
- Line 9: Bounds check: `a2 >= *a1` â†’ `0 >= INT64_MAX` = FALSE (passes)
- Line 9: Bounds check: `a3 >= a1[1]` â†’ `1 >= 2` = FALSE (passes)
- Line 14: `v8 = a3 * *a1 + a2` = `1 * INT64_MAX + 0` = **INT64_MAX**
- Line 15: `v7 = v8 / 8` = `INT64_MAX / 8` = **0x0FFFFFFFFFFFFFFF** (huge!)
- Line 19: `result = a1[2] + v7` = `tiny_buffer + 0x0FFFFFFFFFFFFFFF`
- **Result:** **Out-of-bounds write to arbitrary memory!** ðŸŽ¯

## The Exploit

**We can write to ANY memory address!**

**Strategy:**
1. Create bitmap with `create(9223372036854775807, 2)`
2. Calculate target address offset
3. Use `set(b1, x, y, value)` to write to target
4. Overwrite GOT entry or function pointer
5. Trigger execution â†’ RCE!

## Calculating Write Address

**To write to address `target_addr`:**
- We need: `bitmap_data_ptr + (y * width + x) / 8 = target_addr`
- With `width = INT64_MAX`, `y * width` can be any value
- Solve for `y`: `y = (target_addr - bitmap_data_ptr) * 8 / width`
- But with `width = INT64_MAX`, this is tricky...

**Better approach:**
- Use `y=1`: offset = `1 * INT64_MAX / 8 = 0x0FFFFFFFFFFFFFFF`
- This is a huge offset, likely beyond heap
- Need to find where this lands, or use different y values

**Alternative:**
- Try `y=0`: offset = `0 * INT64_MAX / 8 = 0` (within buffer)
- Try `y=1`: offset = `INT64_MAX / 8` (way beyond)
- Need intermediate values or heap grooming

## Next Steps

1. **Test with different y values** to see where writes land
2. **Use GDB** to trace the actual write address
3. **Calculate exact y value** to hit GOT (0x409048)
4. **Craft final exploit** to overwrite `printf@GOT` with `system@PLT`

