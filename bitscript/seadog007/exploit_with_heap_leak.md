# Exploit Strategy Using Heap Address Leak

## What We Have

From the type confusion vulnerability, we can leak heap addresses:
- **Leaked address**: `244798176` (0xE98F660) - string structure address
- This gives us a **reference point** in the heap

## Heap Layout Calculation

### String Structure Layout
```
Offset 0x00: length (QWORD, 8 bytes)
Offset 0x08: data pointer (QWORD, 8 bytes)
Total: 16 bytes (0x10)
```

### Variable Entry Layout
```
Offset 0x00-0x1F: name[32] (32 bytes)
Offset 0x20: type (4 bytes)
Offset 0x24: padding (4 bytes)
Offset 0x28: value_ptr (8 bytes) ← Points to string structure
Offset 0x30: prev (8 bytes)
Offset 0x38: next (8 bytes)
Total: 64 bytes (0x40)
```

### Relationship

If we know:
- **String structure address**: `0xE98F660` (from leak)
- **Variable entry's value_ptr** points to this string structure

Then:
- **Variable entry address** ≈ `0xE98F660 - some_offset`
- The variable entry was allocated **before** the string structure
- Typical malloc behavior: allocations are often sequential or nearby

## Exploitation Strategy

### Step 1: Leak Multiple Addresses

```bitscript
int a = 0;
string a = "abc";
int addr_a = a;  // Leaks string address for "abc"

int b = 0;
string b = "def";
int addr_b = b;  // Leaks string address for "def"

// Calculate difference to understand heap layout
```

### Step 2: Find Variable Table Entry

**Option A: Calculate from String Address**
- Variable entry's `value_ptr` points to string structure
- Variable entry is allocated before string
- Estimate: variable entry ≈ `string_addr - 0x100` to `string_addr - 0x1000`
- Use bitmap overflow to scan this range

**Option B: Use OOB Read**
- Use bitmap overflow to read from heap
- Look for pattern: variable name "a" at offset 0x00
- Found entry when name matches

### Step 3: Corrupt Variable Entry

Once we find the variable entry address:

```bitscript
bitmap b1 = create(9223372036854775807, 2);

// Calculate y to hit variable entry's value_ptr (offset 0x28)
// entry_addr + 0x28 = target
// bitmap_data_ptr + (y * INT64_MAX + x) / 8 = entry_addr + 0x28

// Write printf@GOT address (0x409048) to value_ptr
// Write bit by bit using set()
```

### Step 4: Read libc Address

```bitscript
int libc_leak = a;  // Now reads from printf@GOT
print(libc_leak);   // Prints libc's printf address
```

### Step 5: Calculate and Write system

```bitscript
// Calculate system address
// system = libc_base + system_offset

// Write system to printf@GOT using bitmap overflow
// Target: 0x409048 (printf@GOT)
```

### Step 6: Trigger RCE

```bitscript
print("/bin/sh");  // Calls system("/bin/sh")
```

## Practical Challenges

### Challenge 1: Finding Variable Entry Address

**Solution:** Use multiple leaks to calculate heap layout:
```bitscript
int a = 0; string a = "A"; int addr_a = a;
int b = 0; string b = "B"; int addr_b = b;
int c = 0; string c = "C"; int addr_c = c;

// Calculate spacing between allocations
// Estimate where variable entries are
```

### Challenge 2: Finding Bitmap Data Buffer Address

**Solution:** 
- Bitmap is allocated after variables
- Calculate: `bitmap_data_ptr ≈ last_string_addr + offset`
- Or use OOB read to find it

### Challenge 3: Bit-by-Bit Write

**Solution:** Pre-calculate all bit positions for target address:
- `0x409048` in binary
- Write each set bit using `set(b1, x + bit_pos, y, 1)`

## Simplified Approach

Given the complexity, a **practical approach**:

1. **Use string overflow** (already working) to corrupt variable table
2. **Use type confusion** to leak heap addresses
3. **Use leaked addresses** to calculate precise locations
4. **Use bitmap overflow** to write to calculated addresses
5. **Achieve RCE** through GOT overwrite

## Conclusion

The heap address leak (`244798176`) is **valuable** because:
- ✅ Gives us a reference point in heap
- ✅ Can calculate other heap addresses
- ✅ Enables precise corruption with bitmap overflow
- ✅ Part of a complete exploit chain

This is a **critical step** toward full RCE!

