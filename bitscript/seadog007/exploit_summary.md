# RCE Exploit - Information Summary

## âœ… What We Have (Complete)

**Addresses:**
- `printf@GOT`: **0x409048** (target for overwrite)
- `puts@GOT`: **0x409038** (alternative)
- `printf@PLT`: **0x4011f0**
- `puts@PLT`: **0x4011d0**

**ROP Gadgets:**
- `pop rdi ; ret`: **0x404f4d**
- `pop rsi ; pop r15 ; ret`: **0x405711**
- `ret`: **0x40101a**

**Binary Info:**
- No PIE (base: 0x400000) âœ…
- Partial RELRO (GOT writable) âœ…
- No stack canary âœ…
- NX enabled âœ…

**Vulnerability:**
- Heap overflow confirmed âœ…
- Segfault at 0x404d54 âœ…

## âŒ What We're Missing

### 1. **system() Function**
- Not imported in binary
- Need: libc base + system offset, OR
- Need: execve address, OR  
- Need: one_gadget address

### 2. **Write Primitive to GOT**
- Heap overflow writes to heap
- GOT is at 0x409048 (different region)
- Need: Way to write from heap to GOT

**Possible Solutions:**
- Corrupt variable's value_ptr â†’ point to GOT â†’ use assignment
- Corrupt heap metadata â†’ arbitrary write
- Corrupt function pointer â†’ redirect execution

### 3. **"/bin/sh" String Address**
- Not in binary
- Solution: Create via `string cmd = "/bin/sh";` and use its heap address

## Exploitation Path

### Best Option: Variable Assignment Write Primitive

**The Idea:**
1. Heap groom: Place variable entry adjacent to overflow
2. Overflow: Corrupt variable entry's `value_ptr` (offset 0x28)
3. Set `value_ptr` to `printf@GOT` (0x409048)
4. Assignment: `variable = system_address` writes to GOT!
5. Trigger: `print("/bin/sh")` â†’ `system("/bin/sh")`

**But we need system address!**

### Alternative: Use libc system()

If libc is loaded:
1. Leak libc base address (need info leak)
2. Calculate: `system_addr = libc_base + system_offset`
3. Write to GOT
4. Execute

### Or: Use ROP with execve

If we can't get system:
1. Build ROP chain: pop rdi + "/bin/sh" + pop rsi + NULL + pop rdx + NULL + execve
2. Need execve address (from libc)
3. Overwrite return address with ROP chain

## What You Need to Provide

1. **libc information:**
   ```bash
   ldd ./bitscript
   /lib/x86_64-linux-gnu/libc.so.6
   ```

2. **system/execve offsets:**
   ```bash
   readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
   readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep execve
   ```

3. **Heap layout (from GDB):**
   - Where does overflow write?
   - What structures are adjacent?
   - Can we reach variable entries?

## ğŸ¯ BREAKTHROUGH: Arbitrary Write Primitive Found!

**NEW VULNERABILITY: Bitmap Create Signed Overflow**
- `create(9223372036854775807, 2)` bypasses bounds check âœ…
- Allocates tiny buffer but `width = INT64_MAX`
- `set(b1, x, y, value)` can write to **ANY address!**
- **We now have an arbitrary write primitive!** ğŸ‰

## Current Status

âœ… **All addresses collected**  
âœ… **ROP gadgets ready**  
âœ… **Vulnerability confirmed**  
âœ… **Arbitrary write primitive found!** ğŸ¯
â³ **Need: system/execve address**  
â³ **Need: Calculate exact y value to hit GOT**  
â³ **Need: Handle bit-level writes (set() only writes bits)**

**The bitmap_create overflow is MUCH better than string concatenation!**
- Direct arbitrary write (no heap grooming needed)
- Can target GOT directly
- Just need to calculate the right y value

With this, we can craft the final RCE exploit!

