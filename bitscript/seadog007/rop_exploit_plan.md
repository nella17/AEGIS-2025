# ROP Exploit Plan - Using Available Gadgets

## Key ROP Gadgets Found

✅ **pop rdi ; ret** - `0x404f4d` (for first argument)  
✅ **pop rsi ; pop r15 ; ret** - `0x405711` (for second argument, need to pop r15 too)  
✅ **ret** - `0x40101a` (for chaining)  

## ROP Chain Structure

For `system("/bin/sh")`:
```
pop rdi ; ret          (0x404f4d)
"/bin/sh" address      (pointer to "/bin/sh" string)
system@PLT             (address of system function)
```

## What We Still Need

### 1. GOT/PLT Addresses
```bash
objdump -R ./bitscript | grep -E "(printf|puts|system)"
objdump -d ./bitscript | grep -A 5 "system@plt"
```

### 2. "/bin/sh" String Address
- Option A: Find in binary (unlikely)
- Option B: Write to heap via string variable, then use its address
- Option C: Use existing string and calculate address

### 3. Write Primitive
**Challenge:** Heap overflow may not directly reach:
- Stack (for ROP chain)
- GOT (for overwrite)

**Solutions:**
1. **Heap-to-Stack:** If we can corrupt a pointer that writes to stack
2. **Heap-to-GOT:** If heap and GOT are close (unlikely)
3. **Function Pointer Hijack:** Corrupt function pointer in heap structure
4. **Return Address Overwrite:** If we can reach stack from heap

## Exploitation Strategy

### Strategy 1: Function Pointer Hijack (Most Likely)

**Target:** Corrupt a function pointer in:
- AST node (if it has function pointers)
- Variable table entry (unlikely)
- Heap structure that gets called

**Steps:**
1. Heap groom to place target structure near overflow
2. Trigger overflow to overwrite function pointer
3. Set pointer to `system@PLT`
4. Trigger function call → executes `system()`

### Strategy 2: GOT Overwrite via Heap Metadata

**If we can get arbitrary write:**
1. Corrupt heap chunk metadata
2. Use heap operations to write to GOT
3. Overwrite `printf@GOT` with `system@PLT`
4. Call `print("/bin/sh")` → `system("/bin/sh")`

### Strategy 3: ROP Chain on Stack

**If we can reach stack:**
1. Build ROP chain: `pop rdi` + "/bin/sh" + `system@PLT`
2. Overwrite return address with ROP chain
3. Function returns → executes ROP chain → shell

## Next Steps

1. **Get GOT/PLT addresses:**
   ```bash
   objdump -R ./bitscript
   objdump -d ./bitscript | grep system
   ```

2. **Find "/bin/sh" or create it:**
   - Check if exists in binary
   - Or create via: `string cmd = "/bin/sh";` and use its address

3. **Determine write target:**
   - What can we overwrite with heap overflow?
   - Can we reach stack? GOT? Function pointers?

4. **Craft final exploit:**
   - Use ROP gadgets to set up arguments
   - Call system("/bin/sh")

