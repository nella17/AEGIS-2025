# RCE Exploit Strategy - Based on Binary Protections

## Binary Protection Analysis

✅ **No PIE (0x400000)** - **EXCELLENT!** All addresses are fixed  
✅ **Partial RELRO** - **EXCELLENT!** GOT can be overwritten  
✅ **No Stack Canary** - Stack exploits possible  
⚠️ **NX Enabled** - Need ROP, not shellcode  
⚠️ **SHSTK/IBT** - May complicate some techniques, but shouldn't block ROP

## Exploitation Strategy

### Option 1: GOT Overwrite (EASIEST)

**Why this works:**
- Partial RELRO means GOT is writable
- No PIE means GOT address is fixed
- We can overwrite GOT entries with our target function

**Target:**
- Overwrite `printf@GOT` or `puts@GOT` with `system@PLT`
- When program calls `print()`, it will call `system()` instead
- Pass "/bin/sh" as argument

**Steps:**
1. Find GOT address of `printf` or `puts`
2. Find `system@PLT` address
3. Use heap overflow to write `system` address to GOT entry
4. Call `print("/bin/sh")` to execute `system("/bin/sh")`

### Option 2: ROP Chain

**Why this works:**
- No PIE = fixed addresses
- No stack canary = can overwrite return address
- NX = need ROP, not shellcode

**Steps:**
1. Find ROP gadgets in binary
2. Build ROP chain: `pop rdi; ret` + "/bin/sh" address + `system@PLT`
3. Overwrite return address on stack with ROP chain
4. Return to ROP chain → execute system("/bin/sh")

### Option 3: Function Pointer Hijack

**Why this works:**
- We're corrupting heap structures
- AST nodes or variable entries might have function pointers
- Redirect to `system@PLT`

## Required Addresses

### From Binary (Fixed at 0x400000 base):

**GOT Entries:**
- `printf@GOT` - Address of printf in GOT
- `puts@GOT` - Address of puts in GOT
- `free@GOT` - Address of free in GOT

**PLT Entries:**
- `system@PLT` - Address of system function
- `execve@PLT` - Alternative target

**Functions:**
- `eval_statement` - 0x404c35 (we know this)
- `eval_expression` - 0x403fcd
- `print` function - Need to find

**ROP Gadgets:**
- `pop rdi; ret` - For setting first argument
- `pop rsi; ret` - For setting second argument
- `pop rdx; ret` - For setting third argument
- `ret` - For chaining

## How to Find Addresses

```bash
# Find GOT addresses
objdump -R ./bitscript | grep -E "(printf|puts|system)"

# Find PLT addresses
objdump -d ./bitscript | grep -E "<(system|printf|puts)@plt>"

# Find ROP gadgets
ROPgadget --binary ./bitscript | grep -E "(pop rdi|pop rsi|ret)"

# Find string "/bin/sh" or create it
strings ./bitscript | grep bin
# Or we can write it to heap via string variable
```

## Exploit Payload Structure

### For GOT Overwrite:

1. **Heap Grooming:**
   - Allocate strings/bitmaps to shape heap
   - Place target GOT address near overflow location

2. **Trigger Overflow:**
   - Build large strings
   - Concatenate to trigger overflow
   - Overwrite GOT entry with `system@PLT`

3. **Trigger Execution:**
   - Call `print("/bin/sh")`
   - This calls `printf("/bin/sh")` → but GOT points to `system`
   - Executes `system("/bin/sh")` → RCE!

### For ROP Chain:

1. **Stack Overflow or Heap-to-Stack:**
   - Corrupt return address on stack
   - Or use heap-to-stack write primitive

2. **Build ROP Chain:**
   - Overwrite return address with ROP chain
   - Chain: pop rdi → "/bin/sh" → system → exit

3. **Return:**
   - Function returns → executes ROP chain
   - RCE achieved

## Next Steps

1. **Find GOT/PLT addresses:**
   ```bash
   objdump -R ./bitscript
   objdump -d ./bitscript | grep -A 5 "system@plt"
   ```

2. **Find ROP gadgets:**
   ```bash
   ROPgadget --binary ./bitscript
   ```

3. **Test heap layout:**
   - Use GDB to see where overflow writes
   - Identify what structures are adjacent

4. **Craft exploit:**
   - Write address to GOT entry
   - Trigger function call
   - Get shell!

## Advantages of This Binary

✅ **No PIE** - All addresses known  
✅ **Partial RELRO** - GOT writable  
✅ **No Stack Canary** - Stack exploits work  
✅ **Heap overflow confirmed** - We can write anywhere in heap  

This is a **very exploitable** binary! GOT overwrite should be straightforward.

