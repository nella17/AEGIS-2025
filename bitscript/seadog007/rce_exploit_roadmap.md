# RCE Exploit Roadmap

## Current Assets

### ✅ Confirmed Vulnerabilities:
1. **Type Confusion Heap Leak** - Can leak heap addresses
2. **Bitmap Overflow** - Arbitrary write primitive
3. **Use-After-Free** - Heap grooming and corruption
4. **Double Free** - Heap corruption (backup option)

### ✅ Known Addresses:
- `printf@GOT` = `0x409048` (target for overwrite)
- Binary base = `0x400000` (No PIE)
- GOT is writable (Partial RELRO)

## RCE Exploit Chain

### Step 1: Leak Heap Addresses ✅
**Status:** Already working
```bitscript
int leak1 = 0;
string leak1 = "first";
int addr1 = leak1;  // Leaks heap address
```

**Goal:** Get heap addresses to calculate variable entry locations

### Step 2: Find Variable Entry Address
**Status:** Need to implement
**Method:** Use heap leak + OOB read or calculation

**Options:**
- **Option A:** Use OOB read from bitmap to scan heap
- **Option B:** Calculate from leaked string address (estimate offset)
- **Option C:** Use use-after-free to read variable table entries

**Target:** Find address of a variable entry we can control (e.g., `target` variable)

### Step 3: Corrupt Variable's value_ptr to printf@GOT
**Status:** Need to implement
**Method:** Use bitmap overflow to write `0x409048` to `variable_entry + 0x28`

**Requirements:**
- Variable entry address (from Step 2)
- Bitmap buffer address
- Calculate y and x coordinates for bitmap overflow

**Code:**
```bitscript
bitmap b1 = create(9223372036854775807, 2);
// Calculate: value_ptr_addr = entry_addr + 0x28
// Calculate: offset = value_ptr_addr - bitmap_data_ptr
// Calculate: y = (offset * 8) / INT64_MAX, x = (offset * 8) % 8
// Write 0x409048 bit-by-bit using set()
```

### Step 4: Leak Libc Address
**Status:** Need to implement
**Method:** Read from corrupted variable (now points to printf@GOT)

**Code:**
```bitscript
string target = "dummy";
// After corrupting target.value_ptr to printf@GOT:
int libcprintf = target;  // Reads printf address from GOT
```

### Step 5: Calculate system() Address
**Status:** Need libc offsets
**Method:** Calculate from leaked printf address

**Requirements:**
- Get libc version and offsets
- `libc_base = libc_printf_addr - printf_offset`
- `system_addr = libc_base + system_offset`

**How to get offsets:**
```bash
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
```

### Step 6: Overwrite printf@GOT with system()
**Status:** Need to implement
**Method:** Use bitmap overflow again to write system_addr to 0x409048

**Code:**
```bitscript
// Calculate coordinates for 0x409048
// Write system_addr bit-by-bit using set()
```

### Step 7: Trigger RCE
**Status:** Simple
**Method:** Call print() which internally calls printf()

**Code:**
```bitscript
print("/bin/sh");  // Calls printf, but printf@GOT now points to system()
// → system("/bin/sh") → SHELL!
```

## Implementation Priority

### Phase 1: Address Finding (Critical)
1. **Find variable entry address**
   - Use heap leak + calculation
   - Or use OOB read to scan heap
   - Or use use-after-free to read variable table

2. **Find bitmap buffer address**
   - Use heap leak + calculation
   - Or use OOB read

### Phase 2: Arbitrary Write Setup
3. **Implement bit-by-bit write function**
   - Write 64-bit value to arbitrary address
   - Use bitmap overflow with calculated coordinates

4. **Corrupt variable entry**
   - Write printf@GOT address to value_ptr

### Phase 3: Libc Leak
5. **Read libc address**
   - Use corrupted variable to read from GOT

6. **Calculate system address**
   - Get libc offsets
   - Calculate system() address

### Phase 4: RCE
7. **Overwrite GOT**
   - Write system() address to printf@GOT

8. **Trigger shell**
   - print("/bin/sh")

## Next Immediate Steps

### 1. Find Variable Entry Address
**Try this approach:**
```bitscript
// Leak heap address
int leak = 0;
string leak = "marker";
int heapaddr = leak;

// Estimate variable entry is ~0x300 bytes before string
// entry_addr ≈ heapaddr - 0x300
// value_ptr = entry_addr + 0x28
```

### 2. Find Bitmap Buffer Address
**Try this approach:**
```bitscript
bitmap b1 = create(9223372036854775807, 2);
// Bitmap buffer is allocated after variables
// Estimate: bitmap_data_ptr ≈ heapaddr + 0x1000
```

### 3. Test Address Calculations
**Create test script:**
- Leak addresses
- Calculate entry and bitmap addresses
- Try to write test value
- Verify it works

### 4. Implement Full Exploit
**Once addresses are found:**
- Write printf@GOT to variable entry
- Read libc address
- Calculate system address
- Write system to GOT
- Trigger shell

## Alternative Approaches

### If Address Finding Fails:
1. **Use OOB read** to scan heap systematically
2. **Use use-after-free** to read variable table entries directly
3. **Use heap grooming** to control allocation order
4. **Use double free** for heap corruption (backup)

### If Bitmap Overflow Fails:
1. **Use use-after-free** to corrupt variable entries
2. **Use double free** for fastbin attack
3. **Combine multiple vulnerabilities** for more reliable exploit

## Tools Needed

1. **Libc offsets:**
   ```bash
   readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep -E "(printf|system)"
   ```

2. **GDB for debugging:**
   - Set breakpoints
   - Inspect heap layout
   - Verify addresses

3. **Python script:**
   - Calculate coordinates
   - Generate bit-by-bit writes
   - Format exploit payload

## Success Criteria

✅ **RCE achieved when:**
- Can execute arbitrary commands
- Get shell via `print("/bin/sh")`
- Or execute system() with controlled arguments

## Current Blockers

1. **Need exact addresses:**
   - Variable entry address
   - Bitmap buffer address

2. **Need libc offsets:**
   - printf offset
   - system offset

3. **Need bit-by-bit write implementation:**
   - Convert address to bit coordinates
   - Write bits using set()

## Recommended Next Action

**Start with Step 1-2: Address Finding**

Create a script that:
1. Leaks heap addresses
2. Estimates variable entry and bitmap buffer addresses
3. Tests if estimates are correct
4. Refines estimates based on results

Once addresses are found, the rest is straightforward!

