# RCE Exploit Strategy - Bitmap Create Arbitrary Write

## âœ… BREAKTHROUGH: Arbitrary Write Primitive Found!

**The Vulnerability:**
- `create(9223372036854775807, 2)` bypasses bounds check via signed overflow
- Allocates tiny buffer but stores `width = INT64_MAX`
- `set(b1, x, y, value)` calculates: `offset = (y * INT64_MAX + x) / 8`
- **We can write to ANY address!** ðŸŽ¯

## What We Have

**Addresses:**
- `printf@GOT`: **0x409048** (target)
- `printf@PLT`: **0x4011f0**
- `puts@GOT`: **0x409038** (alternative)

**ROP Gadgets:**
- `pop rdi ; ret`: **0x404f4d**
- `pop rsi ; pop r15 ; ret`: **0x405711**
- `ret`: **0x40101a**

**Binary:**
- No PIE âœ…
- Partial RELRO âœ…
- No stack canary âœ…

## The Exploit Plan

### Step 1: Create Vulnerable Bitmap
```bitscript
bitmap b1 = create(9223372036854775807, 2);
```

### Step 2: Calculate Write Address

**To write to `printf@GOT` (0x409048):**
- We need: `bitmap_data_ptr + offset = 0x409048`
- Where: `offset = (y * INT64_MAX + x) / 8`
- Solve for `y` and `x`

**Challenge:** We need to know `bitmap_data_ptr` (heap address)

**Solution Options:**
1. **Use GDB** to find heap address at runtime
2. **Heap grooming** to place bitmap at predictable location
3. **Brute force** with different y values
4. **Use relative offsets** if heap and GOT are close

### Step 3: Write system Address to GOT

**Once we can write to 0x409048:**
- Need: `system@PLT` or `system@libc` address
- Write 8 bytes (QWORD) to GOT entry
- But `set()` only writes 1 bit at a time!

**Problem:** `set()` sets/clears individual bits, not full bytes

**Solution:** Need to write 8 times to set all bits, or find another way

### Step 4: Trigger Execution
```bitscript
print("/bin/sh");
```
- Calls `printf("/bin/sh")` â†’ but GOT points to `system`
- Executes `system("/bin/sh")` â†’ **SHELL!** ðŸŽ‰

## Challenges

1. **Bit-level writes:** `set()` only writes bits, not bytes
   - Need to write 8 times to set a full QWORD
   - Or find byte-level write primitive

2. **Heap address:** Need to know `bitmap_data_ptr`
   - Use GDB to find at runtime
   - Or calculate relative to known addresses

3. **system address:** Still need system/execve
   - Check if available in binary
   - Or use libc base + offset

## Next Steps

1. **Test arbitrary write:**
   ```bitscript
   bitmap b1 = create(9223372036854775807, 2);
   set(b1, 0, 1, 1);  # Test if this causes segfault/corruption
   ```

2. **Find heap address:**
   - Use GDB to inspect `bitmap_data_ptr`
   - Calculate offset to GOT

3. **Calculate y value:**
   - `y = (target_addr - bitmap_data_ptr) * 8 / INT64_MAX`
   - Or use trial and error

4. **Write system address:**
   - If `set()` only does bits, need alternative
   - Or use multiple `set()` calls strategically

