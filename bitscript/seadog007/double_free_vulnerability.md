# Double Free Vulnerability in String Assignment

## Location
`eval_statement` function, ASSIGNMENT case (case 4), lines 66-76

## The Vulnerability

**Code Flow for `qqqq = drgaAyOX;`:**

```c
case 4:  // ASSIGNMENT
  v9 = get_variable("qqqq");  // Get target variable (qqqq)
  v8 = v9;
  eval_expression(v3, drgaAyOX_ast);  // Evaluate source (drgaAyOX)
  // v5 = pointer to drgaAyOX's string struct
  
  if ( *(_DWORD *)(v8 + 32) == 1 && *(_QWORD *)(v8 + 40) ) {  // If string and has old value
    free(*(void **)(*(_QWORD *)(v8 + 40) + 8LL));  // Free old string data ("DDDDDDD")
    free(*(void **)(v8 + 40));  // Free old string struct
  }
  *(_QWORD *)(v8 + 40) = v5;  // Set qqqq.value_ptr = drgaAyOX.value_ptr
```

## The Problem

**After `qqqq = drgaAyOX;`:**

1. **qqqq's old string is freed** ("DDDDDDD")
2. **qqqq.value_ptr is set to drgaAyOX.value_ptr** (pointer copy, NOT deep copy!)
3. **Both variables now point to the SAME string struct!**

**Memory State:**
```
drgaAyOX.value_ptr → [String struct: "CEAslRcADdmKsyLuNMWC"]
qqqq.value_ptr     → [Same string struct] ← SHARED!
```

## Double Free Scenarios

### Scenario 1: Delete Both Variables

```bitscript
qqqq = drgaAyOX;
delete(qqqq);    // Frees the shared string struct
delete(drgaAyOX); // Tries to free the SAME struct → DOUBLE FREE!
```

**What happens:**
1. `delete(qqqq)` → Frees the shared string struct
2. `delete(drgaAyOX)` → Tries to free the already-freed struct → **CRASH/CORRUPTION!**

### Scenario 2: Reassign Both Variables

```bitscript
qqqq = drgaAyOX;
qqqq = "new";      // Frees the shared struct
drgaAyOX = "other"; // Tries to free the SAME struct → DOUBLE FREE!
```

**What happens:**
1. `qqqq = "new"` → Frees qqqq's old value (the shared struct)
2. `drgaAyOX = "other"` → Tries to free drgaAyOX's old value (same struct) → **DOUBLE FREE!**

### Scenario 3: Replace Then Assign

```bitscript
string s1 = "first";
replace(s1, 0, "X");  // Modifies s1 (might allocate new struct)
string s2 = "second";
s2 = s1;  // Both point to same struct
s1 = "new";  // Frees shared struct
s2 = "other"; // Tries to free same struct → DOUBLE FREE!
```

## Root Cause

**The bug:** String assignment does a **shallow copy** (pointer copy) instead of a **deep copy** (allocate new string).

**What should happen:**
```c
// Should create a copy:
new_string_struct = malloc(0x10);
new_string_data = malloc(length + 1);
strcpy(new_string_data, old_string_data);
new_string_struct->length = old_string_struct->length;
new_string_struct->data = new_string_data;
qqqq.value_ptr = new_string_struct;  // New copy!
```

**What actually happens:**
```c
qqqq.value_ptr = drgaAyOX.value_ptr;  // Just copies pointer!
```

## Exploitation Potential

**Double free can lead to:**
1. **Heap corruption** - Corrupts heap metadata (chunk headers)
2. **Use-after-free** - Memory used after being freed
3. **Arbitrary write** - If combined with heap manipulation (fastbin attack, tcache poisoning)
4. **RCE** - Through heap exploitation techniques

**Classic heap exploitation:**
- Corrupt freed chunk's `fd` pointer
- Next `malloc` returns controlled address
- Write to controlled address → GOT overwrite → RCE

## Proof of Concept

I've created two POC scripts:
1. `poc_double_free.bs` - Double free via delete
2. `poc_double_free_reassign.bs` - Double free via reassignment

## Severity

**CRITICAL** - Double free is a serious vulnerability that can lead to:
- Heap corruption
- Arbitrary write
- Remote Code Execution (RCE)

This is a **critical finding** that should be fixed immediately!

