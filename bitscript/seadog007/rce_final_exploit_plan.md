# Final RCE Exploit Plan

## ✅ What We Have

1. **Libc leak** - `0x7ca596e88550` (setvbuf address)
2. **Libc offsets** - setvbuf (0x88550), system (0x58750)
3. **system() address** - `0x7ca596e58750` (137050643072848)
4. **GOT address** - `printf@GOT = 0x409048` (known, no PIE)

## ⏳ What We Need

**Write primitive to write `system_addr` to `0x409048`**

## Options for Writing to GOT

### Option 1: Bitmap Overflow (if we find bitmap buffer)

**Challenge:** Need exact `bitmap_data_ptr` address

**If we find it:**
```
offset = 0x409048 - bitmap_data_ptr
bit_index = offset * 8
Write system_addr (64 bits) starting at x=bit_index, y=0
```

### Option 2: Use-After-Free

**Approach:**
1. Create use-after-free
2. Groom heap to make corrupted variable point to GOT
3. Write through corrupted variable

**Challenge:** Hard to control what gets allocated

### Option 3: Direct GOT Write (if bitmap buffer is near binary)

**If bitmap buffer is allocated near binary base:**
- `bitmap_data_ptr ≈ 0x400000` (binary base)
- `offset = 0x409048 - 0x400000 = 0x9048` (small!)
- `bit_index = 0x9048 * 8 = 295,008`
- Write with `x=295008, y=0`

**This might work!** Let's try it!

### Option 4: Find Bitmap Buffer via OOB Read

**Use OOB read to:**
- Scan heap for bitmap struct
- Find bitmap variable entry
- Read bitmap struct to get data pointer

## Recommended: Try Direct GOT Write First

**Assumption:** Bitmap buffer might be allocated near binary base or at a predictable location.

**Test:**
1. Try `bitmap_data_ptr = 0x400000` (binary base)
2. Calculate offset to GOT
3. Write system_addr
4. Trigger shell

If that doesn't work, try use-after-free approach.

## Next Action

**Create script that tries direct GOT write with different bitmap buffer estimates!**

