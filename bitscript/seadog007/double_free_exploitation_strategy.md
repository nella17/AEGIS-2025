# Double Free Exploitation Strategy

## Confirmed Vulnerability

**Double free occurs when:**
1. Two variables point to the same string struct (via assignment)
2. Cleanup/deallocation tries to free both → double free

## Exploitation Path

### Step 1: Trigger Double Free During Execution

**Goal:** Trigger double free while we can still control execution (not just cleanup)

**Strategy:**
```bitscript
string s1 = "first";
string s2 = "second";
s2 = s1;  // Both point to same struct
delete(s1);  // Free the shared struct
delete(s2);  // Try to free again → double free during execution!
```

**Why this is better:**
- Double free happens during our script execution
- We can control what happens after the double free
- We can use heap corruption immediately

### Step 2: Heap Grooming

**Goal:** Control heap layout to make exploitation reliable

**Strategy:**
1. Allocate multiple strings to control heap layout
2. Trigger double free at a specific location
3. Corrupt heap metadata (chunk headers)

### Step 3: Fastbin Attack / Tcache Poisoning

**Goal:** Gain control over next allocation

**How double free helps:**
1. Free chunk A
2. Free chunk A again (double free)
3. Corrupt chunk A's `fd` pointer (points to next free chunk)
4. Next `malloc` of same size returns our controlled address

**Classic fastbin attack:**
```
Free chunk A → [A] → NULL
Free chunk A again → [A] → [A] → NULL (corrupted!)
Corrupt A->fd to point to target address
Next malloc returns target address
Write to target address → GOT overwrite!
```

### Step 4: Arbitrary Write

**Goal:** Write to `printf@GOT` (0x409048)

**Method:**
1. Use fastbin attack to get allocation at controlled address
2. Write `system()` address to `printf@GOT`
3. Trigger `print("/bin/sh")` → calls `system("/bin/sh")` → RCE!

## Exploit Chain

```
1. Heap Grooming
   ↓
2. Trigger Double Free (during execution)
   ↓
3. Corrupt Heap Metadata (fd pointer)
   ↓
4. Fastbin Attack (control next allocation)
   ↓
5. Write to GOT (printf@GOT = system)
   ↓
6. Trigger RCE (print("/bin/sh"))
```

## Challenges

1. **ASLR:** Need to leak libc address first
   - Use type confusion heap leak (already confirmed)
   - Calculate libc base
   - Calculate system() address

2. **Heap Layout:** Need predictable heap layout
   - Use heap grooming
   - Control allocation order

3. **Double Free Detection:** Modern glibc has protections
   - May need to bypass tcache/fastbin checks
   - Use specific sizes to target specific bins

## Next Steps

1. Create POC that triggers double free during execution (not cleanup)
2. Experiment with heap grooming
3. Attempt fastbin attack
4. Combine with heap leak for libc address
5. Full RCE exploit

